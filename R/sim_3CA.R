#' Simulation function for 3CA
#'
#' This function performs simulation to prove the use of 3CA in estimating the target latent factor. The data will be generated by simulating their covariance matrix.
#' @import MASS
#' @param nt sample size of treatment group.
#' @param nc sample size of control group.
#' @param p dimension of one data type denote as X.
#' @param q dimension of another data type denote as Y.
#' @param s number of non-zero loadings in each singular vector.
#' @param AR: values of the first off-diagonal element for toeplitz matrices which are set to be the error covariance matrix for Xt and Yt. The error covariances for Xc and Yc are set to be identity matrices.
#' @param lambda_t eigenvalues for U1V1, U2V2, U3V3 and U4V4 in treatment group.
#' @param lambda_c eigenvalues for U1V1, U2V2 in control group.
#' @param eta the tuning parameter between treatment and control group, if eta = NULL, will use eta estimation.
#' @param lm_sigma the error standard deviation of regression which is used for validation of methods.
#' @param lm_beta the coefficient of regression which is used for validation of methods.
#' @param repetition the number of replications for simulation.
#' @return A data frame containing the estimation of regression coefficients from 3CA, treatment cross covariance analysis, and cPCA on one data type.
#' @export
#' @examples
#' library(CEA)
#' library(ggsci)
#' library(ggplot2)
#' library(tidyverse)
#' n_candidates <- c(1000, 2000, 3000)
#' AR_candidates <- c(0.5, 0.7, 0.9)
#' results <- setNames(data.frame(matrix(ncol = 6, nrow = 0)),
#'                     c("est_trt_cca", "est_ctst_cca", "est_ctst_pca", "eta_est",
#'                       "SampleSize", "AR"))
#' for (n in n_candidates) {
#'   for (AR in AR_candidates){
#'     res <- sim_3CA(nt = n, nc = n, p = 40, q = 40, s = 10, AR = AR,
#'                     lambda_t = c(6, 4, 2, 0), lambda_c = c(2, 0.2), eta = NULL,
#'                     lm_sigma = 1, lm_beta = 1.5, repetition = 20)
#'    rownames(res) <- NULL
#'    res$SampleSize <- n
#'    res$AR <- AR
#'    results <- rbind(results, res)
#'  }
#'}
#' knitr::kable(results, format = "markdown")
#' plot_results <- pivot_longer(results, 1:3, names_to = "Type", values_to = "Estimation")
#' plot_results$Analysis <- sub(".*?_", "", plot_results$Type)
#' plot_results$SampleSize <- paste("n=", plot_results$SampleSize, sep = "")
#' plot_results$AR <- paste("AR=", plot_results$AR, sep = "")
#' plot_results$Analysis <- factor(plot_results$Analysis, labels = c("ContrastiveCCA", "ContrastivePCA", "TreatmentCCA"))
#' p_est_box <- ggplot(data = plot_results)+
#'      geom_boxplot(aes(x = factor(Analysis, levels=c("ContrastiveCCA", "ContrastivePCA", "TreatmentCCA"), labels=c("3CA", "cPCA", "trtCCA")), y = abs(Estimation), fill = Analysis), show.legend = FALSE)+
#'      facet_grid(cols = vars(SampleSize), rows = vars(AR))+
#'      geom_hline(yintercept = 1.5, linetype = "dashed", color="red")+
#'      scale_y_continuous(breaks = c( 0, 1.5))+
#'      theme_bw()+
#'      theme(
#'        panel.grid = element_blank(),
#'        strip.background = element_rect(fill = "lightblue", color = "black"),
#'        strip.text = element_text(color = "black", face = "bold", size = 14),
#'        text = element_text(size = 14),  # Adjust text size
#'        axis.title = element_text(size = 16),  # Adjust axis title size
#'        axis.text = element_text(size = 12),   # Adjust axis text size
#'      )+
#'      scale_fill_d3()+
#'      labs(y = "Estimation of the coefficient in (3.1)",x="Analysis")
#' print(p_est_box)




sim_3CA <- function(nt, nc, p, q, s, AR,
                    lambda_t = c(3, 2, 1, 0), lambda_c = c(3, 2), eta = NULL,
                    lm_sigma = 1, lm_beta = 1.5, repetition = 10){
  # error covariances
  Phi_t <- toeplitz(AR^(0:(p-1)))
  Phi_c <- diag(1, p)
  Psi_t <- toeplitz(AR^(0:(q-1)))
  Psi_c <- diag(1, q)

  # latent factors
  u1 <- matrix(rep(c(1,0), c(s, p-s)), nrow = p, ncol = 1)
  u2 <- matrix(rep(c(0,1,0), c(s,s, p-2*s)), nrow = p, ncol = 1)
  u3 <- matrix(rep(c(0,0,1,0), c(s,s,s,p-3*s)), nrow = p, ncol = 1)
  u4 <- matrix(rep(c(0,0,0,1,0), c(s,s,s,s,p-4*s)), nrow = p, ncol = 1)

  v1 <- matrix(rep(c(1,0), c(s, q-s)), nrow = q, ncol = 1)
  v2 <- matrix(rep(c(0,1,0), c(s,s, q-2*s)), nrow = q, ncol = 1)
  v3 <- matrix(rep(c(0,0,1,0), c(s,s,s,q-3*s)), nrow = q, ncol = 1)
  v4 <- matrix(rep(c(0,0,0,1,0), c(s,s,s,s,q-4*s)), nrow = q, ncol = 1)

  u1 <- u1/norm(u1,"2")
  u2 <- u2/norm(u2,"2")
  u3 <- u3/norm(u3,"2")
  u4 <- u4/norm(u4,"2")

  v1 <- v1/norm(v1,"2")
  v2 <- v2/norm(v2,"2")
  v3 <- v3/norm(v3,"2")
  v4 <- v4/norm(v4,"2")

  # variance-covariance matrices for (x,y) in treatment group or control group based on paper model

  Sigma_t <- rbind(cbind(lambda_t[1]*u1%*%t(u1)+lambda_t[2]*u2%*%t(u2)+lambda_t[3]*u3%*%t(u3)+lambda_t[4]*u4%*%t(u4)+Phi_t,
                         lambda_t[1]*u1%*%t(v1)+lambda_t[3]*u3%*%t(v3)),
                   cbind(lambda_t[1]*v1%*%t(u1)+lambda_t[3]*v3%*%t(u3),
                         lambda_t[1]*v1%*%t(v1)+lambda_t[2]*v2%*%t(v2)+lambda_t[3]*v3%*%t(v3)+lambda_t[4]*v4%*%t(v4)+Psi_t))
  Sigma_c <- rbind(cbind(lambda_c[1]*u1%*%t(u1)+lambda_c[2]*u2%*%t(u2)+Phi_c,
                         lambda_c[1]*u1%*%t(v1)),
                   cbind(lambda_c[1]*v1%*%t(u1),
                         lambda_c[1]*v1%*%t(v1)+lambda_c[2]*v2%*%t(v2)+Psi_c))

  est_trt_cca <- c()
  est_ctst_cca <- c()
  est_ctst_pca <- c()
  eta_est <- c()

  for (repe in 1:repetition) {
    dat_t <- mvrnorm(n = nt, mu = rep(0, p+q), Sigma = Sigma_t)
    dat_c <- mvrnorm(n = nt, mu = rep(0, p+q), Sigma = Sigma_c)

    Xt <- dat_t[,1:p]
    Yt <- dat_t[,(p+1):(p+q)]
    Xc <- dat_c[,1:p]
    Yc <- dat_c[,(p+1):(p+q)]

    # for each dataset, simulate the response using true loadings and the generated data
    response_x <- Xt %*% u3 * lm_beta + rnorm(nt, sd = lm_sigma)

    Xt <- scale(Xt, center = TRUE, scale = FALSE)
    Yt <- scale(Yt, center = TRUE, scale = FALSE)
    Xc <- scale(Xc, center = TRUE, scale = FALSE)
    Yc <- scale(Yc, center = TRUE, scale = FALSE)

    # eta choice
    if(is.null(eta)){
      eta <- svd(cov(Xt, Yt))$d[1]/svd(cov(Xc, Yc))$d[1]
    }
    eta_est <- c(eta_est, eta)

    # 3CA
    CCA_ctst <- svd(cov(Xt, Yt) - eta*cov(Xc, Yc))
    score_Xctst <- Xt %*% CCA_ctst$u[,1]
    est_ctst_cca <- c(est_ctst_cca, coefficients(lm(response_x~score_Xctst))[2])


    # treatment only cross covariance analysis
    CCA_trt <- svd(cov(Xt, Yt))
    score_Xtrt <- Xt%*%CCA_trt$u[,1]
    est_trt_cca <- c(est_trt_cca, coefficients(lm(response_x~score_Xtrt))[2])

    # cPCA on X
    eta_cpca <- eigen(cov(Xt))$values[1]/eigen(cov(Xc))$values[1]
    PCA_ctst <- list(u=eigen(cov(Xt)-eta_cpca*cov(Xc))$vectors)
    score_XcPCA <- Xt%*%PCA_ctst$u[,1]
    est_ctst_pca <- c(est_ctst_pca, coefficients(lm(response_x~score_XcPCA))[2])
  }
  return(data.frame(est_trt_cca = est_trt_cca,
                    est_ctst_cca = est_ctst_cca,
                    est_ctst_pca = est_ctst_pca,
                    eta_est = eta_est))
}
