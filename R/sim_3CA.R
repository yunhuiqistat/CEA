#' Simulation function for 3CA
#'
#' This function performs simulation to prove the use of 3CA in estimating the target latent factor. The data will be generated by simulating their covariance matrix.
#' @import MASS
#' @param nt sample size of target group.
#' @param na sample size of ancillary group.
#' @param p dimension of one data type denote as X.
#' @param q dimension of another data type denote as Y.
#' @param s number of non-zero loadings in each singular vector.
#' @param AR: values of the first off-diagonal element for toeplitz matrices which are set to be the error covariance matrix for Xt and Yt. The error covariances for Xa and Ya are set to be identity matrices.
#' @param lambda_t eigenvalues for U1V1, U2V2, U3V3 and U4V4 in target group.
#' @param lambda_a eigenvalues for U1V1, U2V2 in ancillary group.
#' @param eta the tuning parameter between target and ancillary group, if eta = NULL, will use eta estimation.
#' @param lm_sigma the error standard deviation of regression which is used for validation of methods.
#' @param lm_beta the coefficient of regression which is used for validation of methods.
#' @param repetition the number of replications for simulation.
#' @return A data frame containing the estimation of regression coefficients from 3CA, target cross covariance analysis, and cPCA on one data type.
#' @export
#' @examples
#' library(CEA)
#' library(ggsci)
#' library(ggplot2)
#' library(tidyverse)
#' n_candidates <- c(1000, 2000, 3000)
#' AR_candidates <- c(0.5, 0.7, 0.9)
#' results <- setNames(data.frame(matrix(ncol = 6, nrow = 0)),
#'                     c("est_trt_cca", "est_ctst_cca", "est_ctst_pca", "eta_est",
#'                       "SampleSize", "AR"))
#' for (n in n_candidates) {
#'   for (AR in AR_candidates){
#'     res <- sim_3CA(nt = n, na = n, p = 40, q = 40, s = 10, AR = AR,
#'                     lambda_t = c(6, 4, 2, 0), lambda_a = c(2, 0.2), eta = NULL,
#'                     lm_sigma = 1, lm_beta = 1.5, repetition = 10)
#'    rownames(res) <- NULL
#'    res$SampleSize <- n
#'    res$AR <- AR
#'    results <- rbind(results, res)
#'  }
#'}
#' knitr::kable(results, format = "markdown")
#' plot_results <- pivot_longer(results, 1:3, names_to = "Type", values_to = "Estimation")
#' plot_results$Analysis <- sub(".*?_", "", plot_results$Type)
#' plot_results$SampleSize <- paste("n=", plot_results$SampleSize, sep = "")
#' plot_results$AR <- paste("AR=", plot_results$AR, sep = "")
#' plot_results$Analysis <- factor(plot_results$Analysis, labels = c("ContrastiveCCA", "ContrastivePCA", "TargetCCA"))
#' p_est_box <- ggplot(data = plot_results)+
#'      geom_boxplot(aes(x = factor(Analysis, levels=c("ContrastiveCCA", "ContrastivePCA", "TargetCCA"), labels=c("3CA", "cPCA", "trtCCA")), y = abs(Estimation), fill = Analysis), show.legend = FALSE)+
#'      facet_grid(cols = vars(SampleSize), rows = vars(AR))+
#'      geom_hline(yintercept = 1.5, linetype = "dashed", color="red")+
#'      scale_y_continuous(breaks = c( 0, 1.5))+
#'      theme_bw()+
#'      theme(
#'        panel.grid = element_blank(),
#'        strip.background = element_rect(fill = "lightblue", color = "black"),
#'        strip.text = element_text(color = "black", face = "bold", size = 14),
#'        text = element_text(size = 14),  # Adjust text size
#'        axis.title = element_text(size = 16),  # Adjust axis title size
#'        axis.text = element_text(size = 12),   # Adjust axis text size
#'      )+
#'      scale_fill_d3()+
#'      labs(y = "Estimation of the coefficient in (3.1)",x="Analysis")
#' print(p_est_box)




sim_3CA <- function(nt, na, p, q, s, AR,
                    lambda_t = c(3, 2, 1, 0), lambda_a = c(3, 2), eta = NULL,
                    lm_sigma = 1, lm_beta = 1.5, repetition = 10){
  # error covariances
  Phi_t <- toeplitz(AR^(0:(p-1)))
  Phi_a <- diag(1, p)
  Psi_t <- toeplitz(AR^(0:(q-1)))
  Psi_a <- diag(1, q)

  # latent factors
  u1 <- matrix(rep(c(1,0), c(s, p-s)), nrow = p, ncol = 1)
  u2 <- matrix(rep(c(0,1,0), c(s,s, p-2*s)), nrow = p, ncol = 1)
  u3 <- matrix(rep(c(0,0,1,0), c(s,s,s,p-3*s)), nrow = p, ncol = 1)
  u4 <- matrix(rep(c(0,0,0,1,0), c(s,s,s,s,p-4*s)), nrow = p, ncol = 1)

  v1 <- matrix(rep(c(1,0), c(s, q-s)), nrow = q, ncol = 1)
  v2 <- matrix(rep(c(0,1,0), c(s,s, q-2*s)), nrow = q, ncol = 1)
  v3 <- matrix(rep(c(0,0,1,0), c(s,s,s,q-3*s)), nrow = q, ncol = 1)
  v4 <- matrix(rep(c(0,0,0,1,0), c(s,s,s,s,q-4*s)), nrow = q, ncol = 1)

  u1 <- u1/norm(u1,"2")
  u2 <- u2/norm(u2,"2")
  u3 <- u3/norm(u3,"2")
  u4 <- u4/norm(u4,"2")

  v1 <- v1/norm(v1,"2")
  v2 <- v2/norm(v2,"2")
  v3 <- v3/norm(v3,"2")
  v4 <- v4/norm(v4,"2")

  # variance-covariance matrices for (x,y) in target group or ancillary group based on paper model

  Sigma_t <- rbind(cbind(lambda_t[1]*u1%*%t(u1)+lambda_t[2]*u2%*%t(u2)+lambda_t[3]*u3%*%t(u3)+lambda_t[4]*u4%*%t(u4)+Phi_t,
                         lambda_t[1]*u1%*%t(v1)+lambda_t[3]*u3%*%t(v3)),
                   cbind(lambda_t[1]*v1%*%t(u1)+lambda_t[3]*v3%*%t(u3),
                         lambda_t[1]*v1%*%t(v1)+lambda_t[2]*v2%*%t(v2)+lambda_t[3]*v3%*%t(v3)+lambda_t[4]*v4%*%t(v4)+Psi_t))
  Sigma_a <- rbind(cbind(lambda_a[1]*u1%*%t(u1)+lambda_a[2]*u2%*%t(u2)+Phi_a,
                         lambda_a[1]*u1%*%t(v1)),
                   cbind(lambda_a[1]*v1%*%t(u1),
                         lambda_a[1]*v1%*%t(v1)+lambda_a[2]*v2%*%t(v2)+Psi_a))

  est_trt_cca <- c()
  est_ctst_cca <- c()
  est_ctst_pca <- c()
  eta_est <- c()

  for (repe in 1:repetition) {
    dat_t <- mvrnorm(n = nt, mu = rep(0, p+q), Sigma = Sigma_t)
    dat_a <- mvrnorm(n = na, mu = rep(0, p+q), Sigma = Sigma_a)

    Xt <- dat_t[,1:p]
    Yt <- dat_t[,(p+1):(p+q)]
    Xa <- dat_a[,1:p]
    Ya <- dat_a[,(p+1):(p+q)]

    # for each dataset, simulate the response using true loadings and the generated data
    response_x <- Xt %*% u3 * lm_beta + rnorm(nt, sd = lm_sigma)

    Xt <- scale(Xt, center = TRUE, scale = FALSE)
    Yt <- scale(Yt, center = TRUE, scale = FALSE)
    Xa <- scale(Xa, center = TRUE, scale = FALSE)
    Ya <- scale(Ya, center = TRUE, scale = FALSE)

    # eta choice
    if(is.null(eta)){
      eta <- svd(cov(Xt, Yt))$d[1]/svd(cov(Xa, Ya))$d[1]
    }
    eta_est <- c(eta_est, eta)

    # 3CA
    CCA_ctst <- svd(cov(Xt, Yt) - eta*cov(Xa, Ya))
    score_Xctst <- Xt %*% CCA_ctst$u[,1]
    est_ctst_cca <- c(est_ctst_cca, coefficients(lm(response_x~score_Xctst))[2])


    # target only cross covariance analysis
    CCA_trt <- svd(cov(Xt, Yt))
    score_Xtrt <- Xt%*%CCA_trt$u[,1]
    est_trt_cca <- c(est_trt_cca, coefficients(lm(response_x~score_Xtrt))[2])

    # cPCA on X
    eta_cpca <- eigen(cov(Xt))$values[1]/eigen(cov(Xa))$values[1]
    PCA_ctst <- list(u=eigen(cov(Xt)-eta_cpca*cov(Xa))$vectors)
    score_XcPCA <- Xt%*%PCA_ctst$u[,1]
    est_ctst_pca <- c(est_ctst_pca, coefficients(lm(response_x~score_XcPCA))[2])
  }
  return(data.frame(est_trt_cca = est_trt_cca,
                    est_ctst_cca = est_ctst_cca,
                    est_ctst_pca = est_ctst_pca,
                    eta_est = eta_est))
}
